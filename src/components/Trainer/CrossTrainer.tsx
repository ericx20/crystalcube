import { useEffect, useRef, useState } from "react";
import {
  Button,
  Heading,
  HStack,
  VStack,
  useClipboard,
  Tooltip,
} from "@chakra-ui/react";

import type { MoveSeq, RotationMove, SolverConfigName } from "src/lib/types";
import { SOLVER_CONFIGS } from "src/lib/constants";
import ScrambleEditor from "./ScrambleEditor";
import SolutionsViewer from "./SolutionsViewer";
import SelectLevel from "./select/SelectLevel";

import { useHotkeys } from "react-hotkeys-hook";
import useScrambleAndSolutions from "src/hooks/useScrambleAndSolutions";
import type { ScrambleMode } from "src/hooks/useScrambleAndSolutions";

import { useAtom } from "jotai";
import { atomWithStorage } from "jotai/utils";
import { getEOSolutionAnnotation, moveSeqToString } from "src/lib";

const scrambleModeAtom = atomWithStorage<ScrambleMode>(
  "cross-scramble-mode",
  "random"
);

const nMoveAtom = atomWithStorage<number>("cross-nmove", 3);

export default function CrossTrainer() {
  const headerRef = useRef<HTMLDivElement>(null);
  const scrollToTop = () => {
    window.scrollTo({
      top: headerRef.current?.offsetTop ?? 0,
      behavior: "smooth",
    });
  };

  const [isSolutionHidden, setSolutionHidden] = useState(true);
  const hideSolution = () => setSolutionHidden(true);
  const showSolution = () => setSolutionHidden(false);

  const actionButtonText = isSolutionHidden ? "reveal" : "next";
  const mainAction = () => {
    if (isSolutionHidden) {
      showSolution();
    } else {
      scrollToTop();
      getNext();
    }
  };

  useHotkeys(" ", mainAction, [isSolutionHidden], { preventDefault: true });
  useHotkeys("Backspace", hideSolution);

  const onNewScramble = hideSolution;

  const [scrambleMode, setScrambleMode] = useAtom(scrambleModeAtom);
  const [nMove, setNMove] = useAtom(nMoveAtom);

  const { scramble, setScramble, solutions, isLoading, getNext } =
    useScrambleAndSolutions("Cross", scrambleMode, nMove, onNewScramble);

  const mask = SOLVER_CONFIGS.Cross.mask;

  return (
    <VStack spacing={4} my={4}>
      <HStack spacing={4} ref={headerRef}>
        <Heading fontSize="2xl">Cross Trainer</Heading>
      </HStack>

      <ScrambleEditor scramble={scramble} setScramble={setScramble} />

      <SolutionsViewer
        scramble={scramble}
        solutions={solutions}
        mask={mask}
        hideSolution={isSolutionHidden}
        onRevealSolution={showSolution}
      >
        <HStack>
          {!isSolutionHidden && (
            <CopyButton
              solverName="Cross"
              scramble={scramble}
              preRotation={["x2"]}
              solutions={solutions}
            />
          )}
          <Button onClick={mainAction} isLoading={isLoading} w="100%">
            {actionButtonText}
          </Button>
          {!isSolutionHidden && <Button onClick={hideSolution}>hide</Button>}
        </HStack>
      </SolutionsViewer>

      <SelectLevel
        solverName="Cross"
        scrambleMode={scrambleMode}
        setScrambleMode={setScrambleMode}
        nMove={nMove}
        setNMove={setNMove}
      />
    </VStack>
  );
}

interface CopyTextProps {
  solverName: SolverConfigName;
  scramble: MoveSeq;
  preRotation: Array<RotationMove>;
  solutions: Array<MoveSeq>;
}

function CopyButton(copyTextProps: CopyTextProps) {
  const copyText = generateCopyText(copyTextProps);
  const { onCopy, hasCopied, setValue } = useClipboard(copyText);
  useEffect(() => {
    setValue(copyText);
  }, [copyText]);
  return (
    <Tooltip label="copied!" isOpen={hasCopied} hasArrow>
      <Button onClick={onCopy}>copy</Button>
    </Tooltip>
  );
}

function generateCopyText({
  solverName,
  scramble,
  preRotation,
  solutions,
}: CopyTextProps): string {
  const isEOStep = !!SOLVER_CONFIGS[solverName].isEOStep;

  const scrambleText = `scramble: ${moveSeqToString(scramble)}`;

  const solutionText = [
    `${solverName} solutions:`,
    ...solutions.map((solution, index) => {
      const prefixText = `${index + 1}.`;
      const movecountText = `(${solution.length} HTM)`; // TODO: compute HTM instead of checking length
      const solutionText = moveSeqToString([...preRotation, ...solution]);
      const eoProgressionText = isEOStep
        ? "[" +
          getEOSolutionAnnotation(scramble, solution)
            .filter((a) => a !== null)
            .join(" ") +
          "]"
        : "";
      return [prefixText, movecountText, solutionText, eoProgressionText]
        .join(" ")
        .trimEnd();
    }),
  ].join("\n");

  const linkText = "generated by https://crystalcube.app";

  return [scrambleText, solutionText, linkText].join("\n\n");
}
